## Globant Challenge

#### My approach of solution for Globant Challenge

### Structure of the project 

```
├── data/
├── logs/
├── src/
│   ├── db_setup/
│   │   ├── __init__.py
│   │   ├── database.py
│   │   ├── models.py
│   │   └── schemas.py
│   ├── routers/
│   │   ├── __init__.py
│   │   ├── backup_table.py
│   │   ├── batch_transactions.py
│   │   ├── full_bulk_insert.py
│   │   └── restore_table.py
│   ├── __init__.py
│   ├── logging_config.py
│   └── main.py
├── .gitignore
├── compose.yml
├── Dockerfile
└── README.md

```

Among the most importat files and dirs of the project tree presented above are:

src/db_setup:
    <ul>
        <li> database.py: Establishes the database connection using SQLAlchemy and creates the session</li>
        <li> models.py: Defines the SQLAlchemy models for the database tables (Department, Job, HiredEmployee)</li>
        <li> schemas.py: Defines the Pydantic schemas for data validation and serialization (Department, Job, HiredEmployee, BatchTransaction)</li>
    </ul>

src/routers:
    <ul>
        <li> backup_table.py: Implements the API endpoint for backing up a specific table to an Avro file</li>
        <li> batch_transactions.py: Implements the API endpoint for inserting batch transactions into the database </li>
        <li> full_bulk_insert.py: Implements the API endpoint for performing a full bulk insert of data from CSV files into the database </li>
        <li> restore_table.py: Implements the API endpoint for restoring a specific table from an Avro backup file </li>
    </ul>

src/main.py:
    <ul>
        <li> Creates the FastAPI application </li>
        <li> Creates the database tables based on the models defined in models.py </li>
        <li> Includes the routers for the different API endpoints (full_bulk_insert, batch_transactions, backup_table, restore_table)</li>
    </ul>

compose.yml: orchestrate the db container and also the fastapi app generated, one of the most importat aspects of the file is the healthcheck definition in the db service, because depends_on ensure dependency between services but <b> does not ensure that the first service is actually available </b>, this caused me many connection refuse problems due to the fact that the app service was up and trying to connect to the db service that was also up but not healthy.


One of the main reason behind chosing fastAPI is in src/db_setup, and was the ability to seamlessly use it together with the abstraction of the modeling of the tables schemas presented and also be able to validate the data being ingested to the database selected, finally the abstraction of the connection to the sql database in a single point basically. 

The modularity of the solution allow to answer all the questions with differents endpoints, because those could be easily added 

### How to run?

<ol> 
<li>
    Create a .env file in the root directory, and fill the following env variables
    ```
    POSTGRES_PASSWORD=
    POSTGRES_DB=
    POSTGRES_USER=
    SQLALCHEMY_DATABASE_URL=postgresql://POSTGRES_USER:POSTGRES_PASSWORD@SERVICE_DB/POSTGRES_DB
    ```
    SERVICE_DB: is the name of the service given to the container associated with the database in compose.yml

    note: this is configured to work with postgres, if you require another relational database engine, must change the env variables accordingly, also must change the db service in the compose.yml file
</li>
<li>
From the root directory run (--build is optional after, an should be used only if you make changes and you want to see them)

`docker compose up --build -d`

you can check if both container (the app and db) are up with 

`docker ps`

if something happen, you can check (I am using the actual names of the services that are defined in the compose.yml file)

`docker compose logs db`
`docker compose logs app`

if you want to take down everything, you can run 

`docker compose down `
</li>
<li>

To check the method, the easiest way is to go directly to the auto docs generated by fast api , and try out there the methods

`http://localhost:8000/docs`

</li>


</ol>

